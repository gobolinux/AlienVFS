#!/usr/bin/lua

-- AlienVFS: a read-only virtual file system for programming language package managers
-- Written by Lucas C. Villa Real <lucasvr@gobolinux.org>
-- Released under the GNU GPL version 2

local inspect = require "inspect"
local inotify = require "inotify"
local flu = require "flu"
local posix = require "posix"
local glob = require "posix.glob"
local stat = require "posix.sys.stat"
local lanes = require "lanes".configure({track_lanes=true})

local pip = require "gobo.alienvfs.pip"
local cpan = require "gobo.alienvfs.cpan"
local lua = require "gobo.alienvfs.luarocks"
local rubygems = require "gobo.alienvfs.rubygems"


-- Basic operations on paths

local Path = {}
Path.__index = Path

function Path:split(path, istart, iend)
    local parts = {}
    for name in string.gmatch(path, "[^/]+") do
		table.insert(parts, name)
    end
    if istart and iend then
        return {table.unpack(parts, istart, iend)}
    end
    return parts
end

function Path:dentry(rootfs, path)
    return rootfs:lookup(path)
end


-- Basic operations on dentries

local Dentry = {}
Dentry.__index = Dentry

function Dentry:create(parent, name, namespace)
    if parent ~= nil and parent.children[name] ~= nil then
        return parent.children[name]
    else
        local dentry = {}
        setmetatable(dentry, Dentry)
        dentry.namespace = namespace
        dentry.name = name
        dentry.parent = parent
        dentry.children = {}
        if parent ~= nil then
            parent.children[name] = dentry
        end
        return dentry
    end
end

function Dentry:remove()
    if self.parent ~= nil then
        self.parent.children[self.name] = nil
    end
end

function Dentry:realpath()
    local dpath = {}
    local dentry = self
    while dentry ~= nil do
        if dentry.namespace == nil then break end
        table.insert(dpath, 1, dentry.name)
        dentry = dentry.parent
    end
    table.insert(dpath, 1, self.namespace)
    return table.concat(dpath, "/")
end

function Dentry:lookup(path)
    local p = Path
    local dentry = self
    if type(path) == "string" then
        for _,name in ipairs(p:split(path)) do
            dentry = dentry.children[name]
            if dentry == nil then break end
        end
    elseif type(path) == "table" then
        for _,name in ipairs(path) do
            dentry = dentry.children[name]
            if dentry == nil then break end
        end
    end
    return dentry
end

function Dentry:populate(filelist, namespace)
    local p = Path
    for _,path in pairs(filelist) do
        for i,name in ipairs(p:split(path)) do
            if i == 1 then
                Dentry:create(self, name, namespace)
            else
                local parent = self:lookup(p:split(path, 1, i-1))
                Dentry:create(parent, name, namespace)
            end
        end
    end
end

function Dentry:getAttributes()
    local path = self:realpath()
    if path:len() == 0 then path = "/" end
    local attrs = stat.lstat(path)
    return {
        dev          = attrs.st_dev,
        ino          = attrs.st_ino,
        mode         = self:makeMode(attrs),
        nlink        = attrs.st_nlink,
        uid          = attrs.st_uid,
        gid          = attrs.st_gid,
        rdev         = attrs.st_rdev,
        access       = attrs.st_atime,
        modification = attrs.st_mtime,
        change       = attrs.st_ctime,
        size         = attrs.st_size,
        blocks       = attrs.st_blocks,
        blksize      = attrs.st_blksize,
    }
end

function Dentry:makeMode(attrs)
    local set = {}
    if stat.S_ISBLK(attrs.st_mode)  ~= 0 then set["blk"]  = true end
    if stat.S_ISCHR(attrs.st_mode)  ~= 0 then set["chr"]  = true end
    if stat.S_ISFIFO(attrs.st_mode) ~= 0 then set["fifo"] = true end
    if stat.S_ISREG(attrs.st_mode)  ~= 0 then set["reg"]  = true end
    if stat.S_ISDIR(attrs.st_mode)  ~= 0 then set["dir"]  = true end
    if stat.S_ISLNK(attrs.st_mode)  ~= 0 then set["lnk"]  = true end
    if stat.S_ISSOCK(attrs.st_mode) ~= 0 then set["sock"] = true end
    if stat.S_IRUSR & attrs.st_mode ~= 0 then set["rusr"] = true end
    if stat.S_IWUSR & attrs.st_mode ~= 0 then set["wusr"] = true end
    if stat.S_IXUSR & attrs.st_mode ~= 0 then set["xusr"] = true end
    if stat.S_IRGRP & attrs.st_mode ~= 0 then set["rusr"] = true end
    if stat.S_IWGRP & attrs.st_mode ~= 0 then set["wusr"] = true end
    if stat.S_IXGRP & attrs.st_mode ~= 0 then set["xusr"] = true end
    if stat.S_IROTH & attrs.st_mode ~= 0 then set["roth"] = true end
    if stat.S_IWOTH & attrs.st_mode ~= 0 then set["woth"] = true end
    if stat.S_IXOTH & attrs.st_mode ~= 0 then set["xoth"] = true end
    if stat.S_ISUID & attrs.st_mode ~= 0 then set["suid"] = true end
    if stat.S_ISGID & attrs.st_mode ~= 0 then set["sgid"] = true end
    return set
end

-- Filesystem notification mechanism

local function add_filesystem_watches(dirs)
    local inotify = require "inotify"
    local handle = nil
    if dirs ~= nil then
        handle = inotify.init()
        for _,path in pairs(dirs) do
            local wd = handle:addwatch(path,
                inotify.IN_CREATE,
                inotify.IN_DELETE,
                inotify.IN_CLOSE_WRITE,
                inotify.IN_MOVED_FROM,
                inotify.IN_MOVE)
            print("adding watch to " .. path)
        end
    end
    return handle
end

local monitor_filesystem_handle = lanes.gen("*", function(ch, prefix, dirs)
    local lanes = require "lanes"
    local posix = require "posix"

    -- XXX catches changes to programs, but not to individual versions
    local handle = add_filesystem_watches(dirs)
    while true do
        local events = handle:read()
        for _, ev in ipairs(events) do
            ch:send("inotify_event", {ev, prefix, dirs[ev.wd]})
        end
    end
end)

local namespace_update = nil

local function bit_set(event, bit)
    return event.mask & bit == bit
end

local function check_filesystem_watches(ch)
    while true do
        local key, value = ch:receive(0, "inotify_event", 1)
        if not key then
            break
        end

        local event_type, event_idx = {'CREATE', 'DELETE', nil}, 3
        local event, prefix, watchdir = value[1], value[2], value[3]
        print("Received event(s) from inotify on " .. watchdir .. ":")

        if bit_set(event, inotify.IN_CREATE) or bit_set(event, inotify.IN_MOVED_TO) then
            print(" * CREATED/MOVED_IN/MODIFIED " .. event.name)
            event_idx = 1
        elseif bit_set(event, inotify.IN_DELETE) or bit_set(event, inotify.IN_MOVED_FROM) then
            print(" * DELETED/MOVED_OUT " .. event.name)
            event_idx = 2
        end

        if event_type[event_idx] ~= nil then
            if prefix == "PIP:" or prefix == "PIP3:" then
                namespace_update(pip, prefix, watchdir, event.name, event_type[event_idx])
            elseif prefix == "LuaRocks:" then
                namespace_update(lua, prefix, watchdir, event.name, event_type[event_idx])
            elseif prefix == "CPAN:" then
                namespace_update(cpan, prefix, watchdir, event.name, event_type[event_idx])
            elseif prefix == "RubyGems:" then
                namespace_update(rubygems, prefix, watchdir, event.name, event_type[event_idx])
            end
        end
    end
end

-- Virtual file system methods

local vfs = {}
vfs.ch = lanes.linda()
vfs.descriptors = {}
vfs.rootfs = Dentry:create(nil, "/")

function vfs.getattr(path, stat)
    if path == "/" then
        return vfs.rootfs:getAttributes()
    else
        local dentry = Path:dentry(vfs.rootfs, path)
        if dentry ~= nil then
            return dentry:getAttributes()
        end
    end
    error(flu.errno.ENOENT)
end

function vfs.readdir(path, filler, fi)
    check_filesystem_watches(vfs.ch)
    local dentry = Path:dentry(vfs.rootfs, path)
    filler(".")
    filler("..")
    for name,dentry in pairs(dentry.children) do
        filler(name)
    end
end

function vfs.open(path, fi)
    -- operates on the real file system
    local dentry = Path:dentry(vfs.rootfs, path)
    local flags = posix.O_RDONLY
    if fi.flags.wronly then
        flags = posix.O_WRONLY
    elseif fi.flags.rdwr then
        flags = posix.O_RDWR
    end
    fi.fh = posix.open(dentry:realpath(), flags)
    vfs.descriptors[fi.fh] = dentry
end

function vfs.read(path, size, offset, fi)
    posix.lseek(fi.fh, math.floor(offset), posix.SEEK_SET)
    return posix.read(fi.fh, size)
end

function vfs.release(path, fi)
    vfs.descriptors[fi.fh] = nil
end


-- Main operation

local function namespace_add_program(prefix, program)
    local pname = Dentry:create(vfs.rootfs, prefix .. program.name)
    local pversion = Dentry:create(pname, program.version)
    if program.filelist ~= nil then
        pversion:populate(program.filelist, program.namespace)
    end
end

local function namespace_create(backend, prefix, namespaces)
    for _,ns in pairs(namespaces) do
        for _,program in pairs(backend:parse(ns)) do
            namespace_add_program(prefix, program)
        end
    end
    monitor_filesystem_handle(vfs.ch, prefix, namespaces)
end

--
-- Update namespace upon a DELETE or CREATE event
-- @backend: pip, lua, cpan, rubygems
-- @prefix: "PIP:", "PIP3:", "LuaRocks:", "CPAN:", "RubyGems:"
-- @watchdir: /System/Aliens/PIP, /System/Aliens/LuaRocks, ...
-- @path: foo, bar, anotherdirname, ...
-- @event_type: 'CREATE', 'DELETE'
--
namespace_update = function(backend, prefix, watchdir, path, event_type)
    if not backend:valid(path) then
        return
    end
    local fullname = "/" .. prefix .. path
    if event_type == "DELETE" then
        local dentry = Path:dentry(vfs.rootfs, fullname)
        if dentry ~= nil then
            dentry:remove()
        end
    elseif event_type == "CREATE" then
        local dentry = Path:dentry(vfs.rootfs, fullname)
        if dentry == nil then
            for _,program in pairs(backend:contents(watchdir, path)) do
                namespace_add_program(prefix, program)
            end
        end
    end
end

local function scan_dirs(root, suffixdir)
    local dirs = {}
    local alt = glob.glob(root)
    if alt then
        for _, ns in pairs(alt) do
            if suffixdir ~= nil then
                table.insert(dirs, ns .. suffixdir)
            else
                table.insert(dirs, ns)
            end
        end
    end
    return table.unpack(dirs)
end

-- Python2
namespace_create(pip, "PIP:", {
    "/System/Aliens/PIP",
    scan_dirs("/System/Aliens/PIP/lib/python2*", "/site-packages"),
    scan_dirs("/Programs/Python/2.*/lib/python2*", "/site-packages")
})

-- Python3
namespace_create(pip, "PIP3:", {
    "/System/Aliens/PIP",
    scan_dirs("/System/Aliens/PIP/lib/python3*", "/site-packages"),
    scan_dirs("/Programs/Python/3.*/lib/python3*", "/site-packages")
})

-- Lua
namespace_create(lua, "LuaRocks:", {
    scan_dirs("/System/Aliens/LuaRocks/lib/luarocks/rocks*", nil)
})

-- CPAN
namespace_create(cpan, "CPAN:", {"/System/Aliens/CPAN"})

-- RubyGems
namespace_create(rubygems, "RubyGems:", {"/System/Aliens/RubyGems"})

-- Run FLU main loop
local argv = {"AlienVFS", "-oallow_other", "-oauto_unmount", select(1, ...)}
flu.main(argv, vfs)

-- vim: ts=4 sts=4 sw=4 expandtab
